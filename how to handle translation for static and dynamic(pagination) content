Static Text / UI Labels

Examples: menu items, buttons, headings, messages like “Submit” or “Welcome”.

Best practice: Store translations in the frontend, e.g., as JSON files or with a library like i18next.

Why:

These rarely change.

Reduces backend/database calls.

Immediate response; smoother UX.

How:

// en.json
{
  "welcome": "Welcome",
  "submit": "Submit"
}

// es.json
{
  "welcome": "Bienvenido",
  "submit": "Enviar"
}


Then load the proper JSON based on user language.

2️⃣ Dynamic Content (DB-driven)

Examples: products, posts, comments, paginated data, user-generated content.

Best practice: Store translations in the database.

Why:

Content may change frequently.

Pagination makes fetching all translations impractical.

Implementation tips:

Store text in separate language columns (e.g., title_en, title_es) or in a translations table.

Fetch only what you need per page.

3️⃣ Hybrid Approach

Static UI → frontend JSON.

Dynamic content → backend DB queries.

Optionally cache translations in the frontend for repeated content, especially if not paginated.

✅ Summary

Frontend storage → static labels, rarely-changing text.

Database → dynamic/paginated content, frequently updated content.

Avoid asking DB for everything if it can be preloaded or cached.

If you want, I can draw a diagram showing the flow of bilingual content from frontend and backend—it makes this hybrid approach super easy to visualize. Do you want me to do that?